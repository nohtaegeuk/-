버블정렬

선택정렬은 가장 작은 값을 선택해서 계속 앞으로 보내는 정렬 방식.

1 10 5 8 7 6 4 3 2 9
버블정렬도 사실 선택정렬과 마찬가지로 쉬운 알고리즘이다.
옆에 있는 값과 비교해서 더 작은 값을 앞으로 보내는 알고리즘이다.

당장 옆에 값과 비교해서 앞으로 보내고, 또 다음 배열과 그 다음 배열의 값을 비교해서 더 작은 값을 앞으로 보내고
사실, 구현은 가장 쉽지만, 가장 비효율적인 알고리즘이다.(선택 정렬보다도 더)

먼저 1과 10을 비교,
10과 5를 비교
10과 8을 비교
7과 10을 비교
6과 10을 비교
4와 10비교
3과 10
2와 10
9와 10
이런 식으로 한 번의 반복이 끝났을 때 가장 큰 값이 맨 마지막으로 보내지게 됨.

1 5 8 7 6 4 3 2 9 10 <<
1과 5
5와 8
- - -
1 5 7 6 4 3 2 8 9 10 <<

1과 5
5와 7
- - -
1 5 6 4 3 2 7 8 9 10 <<
결과적으로 1 2 3 4 5 6 7 8 9 10 이렇게 됨.

#include <stdio.h>

int main(void) {
  
    int i, j, temp;
    int array[10] = {1,10,5,8,7,6,4,3,2,9};
    
    for(int i = 0; i < 10; i++) {
      for(int j = 0; j < 9-i; j++) {
        if(array[j] > array[j+1]){
          temp = array[j];
          array[j] = array[j+1];
          array[j+1] = temp;
        }
      }
    }
    
    for(int i = 0; i < 10; i ++){
      printf("%d", array[i]);
    }
  return 0;
}

한 번 반복을 할 때마다 집합의 크기가 1씩 줄어듬. 
10 9 8 7 6  .. . 1
즉 비교연산의 횟수는 10 + 9 + 8 + 7 -- + 2 + 1
등차수열이기 때문에, N*(N+1) / 2가 됨.
더하기와 나누기 같은 연산 이 N이 엄청 크다는 가정하에, O(N*N)이 됨.
선택정렬과 동일한 시간복잡도이다.

버블정렬이 선택정렬보다 더 느린 이유는 무엇일까?
버블정렬은 당장 옆의 값과 비교해서 계속해서 자리를 바꾸는 연산을 실행한다.
반면에, 선택정렬은 가장 작은 것을 한 번 골라서 마지막에만 한 번 연산을 실행하면 된다.

이렇기 때문에, 시간복잡도는 같지만, 실제 시간을 비교하였을때 버블정렬이 선택정렬보다 느리다. 버블정렬이 정렬 알고리즘 중에 가장 느리다.



