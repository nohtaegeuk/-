퀵정렬

앞의 선택, 버블, 삽입 정렬들은 모두 시간복잡도가 O(N*N)이기 때문에 데이터의 갯수가 10만 개만 넘어가도 일반적인 상황에서 사용하기 매우 어렵다.
빠른 알고리즘이 바로 퀵 정렬이다. 
퀵 정렬은 대표적인 '분할 정복'알고리즘으로 평균속도가 O(N*logN)이다.
사실, 여기서 logN은 상수라고 생각할 만큼 작은 숫자이다.

퀵정렬 : 특정한 값을 기준으로 큰 숫자와 작은 숫자를 나누면 어떨까?
퀵 정렬에서는 기준 값이 있습니다. 이것을 피벗이라고한다.(Pivot)기준이 되는 것들을 말함.

특정한 피벗 값을 기준으로 왼쪽과 오른쪽 값을 나누는 것을 의미.

예를들어, 3 7 8 1 5 9 6 10 2 4
일반적으로 퀵정렬 같은 경우에는 가장 앞에 있는 값을 피벗값으로 설정한다.

현재, 전체 배열에서 가장 앞에 있는 값을 피벗 값으로 설정한 뒤에 왼쪽에서 오른쪽으로 이동, 오른쪽에서 왼쪽으로 이동한다.

왼쪽에서 시작하는 것 : 3보다 큰 7이 선택.
오른쪽에서 시작하는 것 : 3보다 작은 값인 2를 선택
7과 2를 바꾸어줌. >> 3 2 8 1 5 9 6 10 7 4

바뀐 뒤에도 피벗 값은 3이다.
왼쪽 : 8이 선택
오른쪽 : 1선택 >> 3 2 1 8 5 9 6 10 7 4

왼쪽 : 8선택
오른쪽 : 1선택 // 이럴경우에는 index값이 엇갈렸다.
이 엇갈렷을 경우에는 1과 3으르 바꾸어준다 ?? 1 2 3 8 5 9 6 10 7 4
이렇게 되면 3은 정렬이 이루어 졌다 라고 할 수 있다. >> 한 번 분할을 하였다 라고 한다.
분할을 하였을 때 분할점을 기준으로 왼쪽은 작고, 오른쪾은 크다.

왼쪽에서는 가장 앞에있는 값 1이 피벗이 된다.
또 오른쪾에서는 가장 앞에있는 값인 8이 된다.
1 2 3 /  8 5 9 6 10 7 4

1 2 3 8 5 4 6 10 7 9 > 1 2 3 8 5 4 6 7 10 9
이렇게 되면 엇갈리기 떄문에
1 2 3 7 5 4 6 8 10 9
- - - 1 2 3 4 5 6 7 8 9 10

퀵정렬은 한 번 정렬을 수행했을 떄, 그 값을 기준으로 왼쪽과 오른쪽으로 나뉘어 진다.

1 2 3 4 5 6 7 8 9  10
이것을 퀵정렬 하면
 1 2 3 4 5 >> 5 * 5 = 25
 6 7 8 9 10 >> 5 * 5 = 25
 
 그 외의 정렬은 10 * 10 = 100
 
 반으로 쪼개는 과정은 2씩 계속 나눈다는 면에서 logN을 할 수 있다.
