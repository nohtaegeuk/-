2. 완전탐색 & 그리디

* 반복과 재귀

	반복과 재귀는 유사한 작업을 수행할 수 있다.
	반복은 수행하는 작업이 완료될 때 까지 계속 반복
	재귀는 주어진 문제의 해를 구하기 위해 동일하면서 더 작은 문제의 해를 이용하는 방법
	 
* 반복 구조 / for, while 이용
	
	초기화 : 반복되는 명령문을 실행하기 전에 조건 검사에 사용할 변수의 초기값 설정
	조건 검사
	반복할 명령문 실행
	업데이트

* 재귀 알고리즘

	해결하려는 문제를 작은 단위로 나누어 동일한 알고리즘을 반복적으로 적용하여 해를 구하는 알고리즘
	재귀적 정의는 두 부분으로 나뉜다.
	하나 또는 그 이상의 기본 경우
		집합에 포함되어 있는 원소로 induction을 생성하기 위한 시드 역할
	하나 또는 그 이상의 유도된 경우
		새로운 집합의 원소를 생성하기 위해 결합되어지는 방법

* 재귀 함수 작성 절차

	더 작은 문제로 표현할 수 있는지 시도
	문제를 직접 풀 수 있는 것이 어떤 경우인지 베이스 케이스 확인
	N이 줄어서 Base case를 만나게 되는지 확인
	베이스케이스와 베이스케이스가 아닌 경우로 나누어 코드를 작성


* 재귀 함수의 비효율성

	함수 호출은 프로그램 메모리 구조에서 스택을 사용한다. 따라서 재귀호출은
	반복적인 스택의 사용을 의미하며 메모리 및 속도에서 성능저하가 발생한다.
	
* 반복 또는 재귀?

	해결한 문제를 고려해서 반복이나 재귀의 방법을 선택
	문제에 따라 재귖거 구현이 간단하고 자연스러운 경우가 있다.
	일반적으로, 재귀적 알고리즘은 반복 알고리즘에 비해 추가적인 메모리와 연산을 필요로 한다.

* 반복과 재귀의 비교

	      재귀           				vs 	            반복
종료      재귀 함수 호출이 종료되는 베이스케이스			반복문의 종료 조건
수행 시간	느림							빠름
메모리 공간	많이사용						적게 사용
소스 코드 길이 	짧고 간결						길다
소스 코드 형태 	선택구조						반복 구조
무한 반복시 	스택 오버 플로우					cpu를 반복해서 점유


2-2 조합적 문제

* TSP 문제
	모든 도시들을 한 번씩 방문하는데 필요한 최소 비용을 구하라.
	시작점은 정해져 있지 않고, 어떤 도시를 선택해야 할지 일단 정함.
	
* 순열
	
	서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것
	순서가 중요한 경우
	서로 다른 n개 중 r개를 택하는 순열은 아래와 같은 표현을 한다 = nPr
	nPr = n * n-1 * n-2 * n-r+1
	nPn = n * n-1 * n-2 * 2 * 1 = n!

* 다수의 알고리즘 문제들은 순서화된 요소들의 집합에서 최선의 방법을 찾는 것과 관련 있다.

* N 개의 요소들에 대해서 n!개의 순열들이 존재한다.
	n>12 인 경우, 시간 복잡도가 폭발적으로 증가한다.

* 순열 문제에서 완전 탐색을 하게 되면 시간이 엄청 걸리지만, 나오긴 한다..

 

2-3 조합

* 순열 OR 조합

	순열 : 선택의 순서가 결과에 영향을 주는 경우
	조합 : 선택의 순서가 결과에 영향을 주지 않는 경우

	

2-4 완전 탐색 기법

* Brute - force 알고리즘이라고 한다

	자료들의 리스트에서 키 값을 찾기 위해 첫 번째 자료부터 비교하면서 진행한다.

	모든 경우의 수를 생성하고 테스트 하기 때문에 수행 속도는 느리지만, 해답을 찾아내지 못할 확률은 작다

	이를 기반으로 백트래킹이나 동적 계ㅅ획법을 이용해서 알고리즘을 개선할 수 있다.

* 완전 탐색

	많은 종류의 문제들이 특정 조건을 만족하는 경우나 요소를 찾는 것이다.

	또한 이들은 전형적으로 순열, 조합, 그리고 부분집합과 같은 조합적 문제들과 연관된다.
	



	
