삽입정렬

삽입정렬도 버블정렬과 선택정렬과 같이 시간복잡도는 O(N*N)이다.

1 10 5 8 7 6 4 3 2 9을 오름차순으로 작성하는 프로그램을 작성하세요.

삽입 정렬은 위의 문제를 풀 때 각 숫자를 적절한 위치에 삽입하는 방법으로 문제를 해결한다.
이전 정렬들은 이루어지고 있는 상태라고 하더라도, 반드시 반복을 수행하는데 반해, 삽입 정렬은 필요할 때만 위치를 바꾸게 된다.

1 10 5 8 7 6 4 3 2 9여기서 삽입 정렬을 사용할 때는
1은 이미 가장 앞에있기 떄문에 삽입할 위치가 없다.
10은 이 앞에 있는 것들을 봤을 때 1보다 크므로 냅둔다.
5는 1과 10사이에 들어가야한다. >> 1 5 10 8 7 6 4 3 2 9
8은 5와 10사이에 들어가야한다. >> 1 5 8 10 7 6 4 3 2 9
7은 5와 8사이에 들어가야한다. >> 1 5 7 8 10 6 4 3 2 9
>> 한개 씩 정렬이 이루어진다.

이것이 더 효율적인 이유는 만약 위의 6을 보게 될 때에는 이미 앞의 숫자들은 정렬되어 있는 상태이기 때문에 전체를 다 살펴볼 필요가 없어지게 된다.

#include<stdio.h>

int main(void) {

  int i,j,temp;
  int array[10] = [1,10,5,8,7,6,4,3,2,9};
  
  for(int i = 0; i < 9; i++) {
    j = i;
    while(array[j] > array[j+1]){
      temp = array[j];
      array[j] = array[j+1];
      array[j+1] = temp;
      j--;
    }
  }
  
  for(int i = 0; i < 10; i++){
    printf("%d", array[i]);
  }
  return 0;
}

삽입정렬은 기본적으로 정렬이 되어있다는 가정한다는 점에서 특정한 경우에 따라 굉장히 빠른 속도를 실행할 수 있다.

예를들어, 2 3 4 5 6 7 8 9 10 1
2는 첫번째니깐 제외
3은 가만히
3과 4도 가만히
4와 5도 가만히
-- 10까지 갈 때까지 굉장히 빠르게 실행이 된다.
2 3 4 5 6 7 8 9 1 10
2 3 4 5 6 7 8 1 9 10
- - - 1 2 3 4 5 6 7 8 9 10
이렇게 특정한 순간에는 굉장이 빠르게 수행한다.

거의 정렬된 상태라면 삽입 정렬만큼 효율적인것이 없다.

