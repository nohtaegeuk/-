2. 정렬 알고리즘의 개요와 선택 정렬(Selection Sort)
정렬문제..

정렬만큼 알고리즘의 효율성 차이를 극명하게 보여주는 것이 없기 때문입니다..
비효율적인 알고리즘부터 효율적인 알고리즘 순으로 하게 되면, 알고리즘의 효율성을 크게 느낄 수 있다.

Q. 다음의 숫자들을 오름차순으로 정렬하는 프로그램을 작성하세요.
>> 컴퓨터에는 과정을 구체적으로 명시해주어야 한다.

핵심 IDEA : 가장 작은 것을 선택해서 제일 앞으로 보내면 어떨까?
 일단, 알고리즘은 바로 소스 코드를 작성하는 것이 아니라, 손으로 한 번 실습해보고 소스코드를 짜는 것이다.
 
 1 10 5 8 7 6 4 3 2 9
 여기서 가장 작은 1을 맨 앞으로, 그 다음에는 2를 맨 앞으로..
 1 2 5 8 7 6 4 3 10 9
 3을 앞으로
 1 2 3 8 7 6 4 5 10 9
 4를 앞으로
 1 2 3 4 7 6 8 5 10 9
 5를 앞으로
 1 2 3 4 5 6 8 7 10 9
 -
 -
 -
 1 2 3 4 5 6 7 8 9 10
 이런식으로 하는것이 선택정렬..
 
 선택정렬 : 가장 작은 것을 선택해서 앞으로 보낸다
 
 #include <stdio.h>
 
 int main(void) {
  int i,j,min,index,temp;
  
  int array[10] = {1,10,5,8,7,6,1,3,2,9};
  
  for( int i = 0; i < 10; i ++) {
    min = 9999; //9999의 의미는 배열안의 어떤 숫자보다 큰 숫자를 의미.
    for(int j = i; j < 10; j++) {
      if(min > array[j]){
        min = array[j];
        index = j;
      }
    }
    
    temp = array[i];
    array[i] = array[index];
    array[index] = temp;
    // 위의 3숫자를 스와핑. 바꾸는 것.
    
  }
  
  for(int i = 0; i < 10; i++){
    printf("%d", array[i]);
  }
  return 0;
 }
 
 
 중요한 것은 선택 정렬이 얼마나 많은 시간을 잡아 먹는지이다.
 정렬하기 위해서는 1~10까지 확인을 해야함 = 10번 / 작은 값을 찾기위해서는 9번 / 8번 / 7번 - - - 1번 = 55번(등차수열)
 등차수열은 10 * (10 + 1) / 2 = 55
 총 10개를 계산하기 위해서 55번의 계산을 해야함.
 수행시간 : N * (N+1) / 2 ==> N*N의 수행시간을 가지고 있다라고 생각함. O(N*N)
 N은 엄청나게 큰 수라고 생각하기 때문에 간단하게 나누거나 더하는 연산은 무시함.
 O(N*N) : 특정한 알고리즘의 수행시간을 가장 간략하게 표현하는 것이 빅-O표기법이다.
 
 대략 데이터의 개수가 10000이라면 일억번정도 계산을 해야한다.
 이런 상황에서 선택정렬을 사용하는 것이 효율적인지 고민을 해야한다.
 
 사실.. 선택정렬은 정렬알고리즘 중에서는 비효율적이고 느린 알고리즘이다.
 
