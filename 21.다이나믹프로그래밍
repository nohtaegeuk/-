21.다이나믹프로그래밍

정말 많이 나오는 개념 중 하나이다.

동적 계획법. 하나의 문제는 단 한번만 풀도록 하는 알고리즘 이다.

한 번 푼 것을 여러 번 다시 푸는 비효율적인 알고리즘을 개선시키는 방법이다.
"다이나믹 프로그래밍이란 하나의 문제를 단 한번만 풀도록 하는 알고리즘이다"

단순 분할 정복으로 풀게 되면 심각한 비효율성을 낳을 수 있다. 피보나치 수열은 특정한 숫자를 구하기 위해 그 앞에 있는 숫자와
두칸 앞에 있는 숫자의 합을 구해야 한다.
피보나치 수열의 점화식 : D[I] = D[I-1] + D[I-2]

1. 큰 문제를 작은 문제로 나눌 수 있다.
2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.
>> 이 두가지 조건을 만족할 때, 다이나믹 프로그래밍을 할 수 있다.
다만 이 과정에서 메모이제이션이 사용된다.
#include <stdio.h>

int dp(int x) {
	if(x == 1) return 1;
	if(x == 2) return 1;
	return dp(x-1) + dp(x-2);
}

int main(void) {
	printf("%d", dp(10));
}

실행결과 : 55

만약에 N번째 수를 구하기 위해서는 몇 번 계산하여야 할까?
N = (N-1) + (N-2) >> 총 연산 횟수는 2의 N제곱이 된다.

한 번 구한 값을 저장을 해서 다시 그 값을 구하게 될때는 연산하지 않고, 값을 가져오기만 하는것.

#include <stdio.h>

int d[100]; // 메모이제이션 기법.  

int dp(int x) {
	if(x == 1) return 1;
	if(x == 2) return 1;
	if(d[x] != 0) return d[x]; // 이미 구한 값이라면 그냥 값을 반환만 해준다. 
	return d[x] = dp(x-1) + dp(x-2);
}

int main(void) {
	printf("%d", dp(50));
}

시간복잡도 : O(N)

시간복잡도가 2의 N제곱에서 O(N)으로 바뀜.
