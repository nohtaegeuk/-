8. 병합정렬 (Merge Sort)

여태까지 배운것 : 선택정렬, 버블정렬, 삽입정렬, 퀵정렬

병합 정렬도 대표적인 분할 정복 방법을 채택한 알고리즘 이기 때문에, O(N * logN)의 시간 복잡도를 가진다.
다만, 퀵정렬은 피벗 값에 따라서 편향되게 분할할 가능성이 있따는 점에서 최악의 경우에는 O( N * N)이 될 수 있다.

하지만, 병합 정렬은 정확히 반절씩 나눈다는 점에서 최악의 경우에도 O(N * log N)이 보장이 된다.

7 6 5 8 3 5 9 1을 오름차순으로 정렬하는 프로그램을 작성하세요.

일단 반으로 쪼겐다. 그 다음에 나중에 합친다.

병합정렬은 항상 반으로 쪼개기 때문에 피벗 값이 없다. 그리고 항상 반으로 나눈 다는 점에서, 단계의 크기가 logN이 된다.

7 6 5 8
3 5 9 1

합칠 떄는 기본적으로 2의 배수만큼 합친다. 
7과 6을 비교 > 6 7
5와 8을 비교 > 5 8

3과 5를 비교 > 3 5
9와 1를 비교 > 1 9
1단계
-----------------

6 7과 5 8을 비교 > 5 6 7 8
3 5와 1 9를 비교 > 1 3 5 9

2단계
----------------

1 3 5 5 6 7 8 9

3단계

------------------------

N = 8일 떄임, 너비가 8
높이는 3단계(3), 높이는 3이다.

log8 = 3이다. 
즉, 높이는 logN , 너비는 N
N * logN 을 무조건 보장한다.

너비가 N이라고 할 수 있는 이유는, 모든 데이터를 검색해야 한다.
즉 7 6 과 5 8을 합칠 때,  7 6 5 8모든 데이터를 다 검색해야한다.

퀵정렬 과 다른점은 : O(N * logN)을 보장한다.
